!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CURR_DIR	Makefile	/^CURR_DIR := $(shell pwd)$/;"	m
DEFAULT_HASH_SIZE	SR_OutHashTable.h	29;"	d
DEFAULT_OFFSET_FILE_NAME	SR_Build_GetOpt.h	52;"	d
DEFAULT_POS_ARR_CAPACITY	SR_OutHashTable.h	31;"	d
DEPENDANTS	Makefile	/^DEPENDANTS = $(SOURCES:.c=.d)$/;"	m
GetHighEndMask	SR_OutHashTable.h	47;"	d
GetNextHashKey	SR_OutHashTable.c	/^static Bool GetNextHashKey(uint32_t* hashKey, uint32_t* pos, const char* query, uint32_t queryLen, uint32_t mask, unsigned char hashSize)$/;"	f	file:	signature:(uint32_t* hashKey, uint32_t* pos, const char* query, uint32_t queryLen, uint32_t mask, unsigned char hashSize)
OPT_BUILD_REQUIRED_NUM	SR_Build_GetOpt.h	31;"	d
OPT_BUILD_TOTAL_NUM	SR_Build_GetOpt.h	28;"	d
OPT_FA_INPUT_FILE	SR_Build_GetOpt.h	37;"	d
OPT_HASH_SIZE	SR_Build_GetOpt.h	46;"	d
OPT_HASH_TABLE_FILE	SR_Build_GetOpt.h	43;"	d
OPT_HELP	SR_Build_GetOpt.h	34;"	d
OPT_OFFSET_FILE	SR_Build_GetOpt.h	49;"	d
OPT_REF_OUTPUT_FILE	SR_Build_GetOpt.h	40;"	d
REFHASHTABLE_H	SR_OutHashTable.h	20;"	d
SOURCES	Makefile	/^SOURCES  := $(wildcard *.c)$/;"	m
SR_BUILD_GETOPT_H	SR_Build_GetOpt.h	20;"	d
SR_Build_Clean	SR_Build_GetOpt.c	/^void SR_Build_Clean(SR_Reference* reference, SR_OutHashTable* refHashTable, SR_Build_Pars* buildPars)$/;"	f	signature:(SR_Reference* reference, SR_OutHashTable* refHashTable, SR_Build_Pars* buildPars)
SR_Build_Clean	SR_Build_GetOpt.h	/^void SR_Build_Clean(SR_Reference* reference, SR_OutHashTable* refHashTable, SR_Build_Pars* buildPars);$/;"	p	signature:(SR_Reference* reference, SR_OutHashTable* refHashTable, SR_Build_Pars* buildPars)
SR_Build_Pars	SR_Build_GetOpt.h	/^typedef struct SR_Build_Pars$/;"	s
SR_Build_Pars	SR_Build_GetOpt.h	/^}SR_Build_Pars;$/;"	t	typeref:struct:SR_Build_Pars
SR_Build_Pars::faInput	SR_Build_GetOpt.h	/^    FILE* faInput;            \/\/ input stream of the fasta file$/;"	m	struct:SR_Build_Pars	access:public
SR_Build_Pars::hashSize	SR_Build_GetOpt.h	/^    unsigned char hashSize;   \/\/ hash size used to index the reference$/;"	m	struct:SR_Build_Pars	access:public
SR_Build_Pars::hashTableOutput	SR_Build_GetOpt.h	/^    FILE* hashTableOutput;    \/\/ output stream of the hash table file$/;"	m	struct:SR_Build_Pars	access:public
SR_Build_Pars::offsetOutput	SR_Build_GetOpt.h	/^    FILE* offsetOutput;       \/\/ output stream of offset position file of the reference and hash table files$/;"	m	struct:SR_Build_Pars	access:public
SR_Build_Pars::refOutput	SR_Build_GetOpt.h	/^    FILE* refOutput;          \/\/ output stream of the reference file$/;"	m	struct:SR_Build_Pars	access:public
SR_Build_SetPars	SR_Build_GetOpt.c	/^void SR_Build_SetPars(SR_Build_Pars* pars, int argc, char* argv[])$/;"	f	signature:(SR_Build_Pars* pars, int argc, char* argv[])
SR_Build_SetPars	SR_Build_GetOpt.h	/^void SR_Build_SetPars(SR_Build_Pars* pars, int argc, char* argv[]);$/;"	p	signature:(SR_Build_Pars* pars, int argc, char* argv[])
SR_Build_ShowHelp	SR_Build_GetOpt.c	/^void SR_Build_ShowHelp(void)$/;"	f	signature:(void)
SR_Build_ShowHelp	SR_Build_GetOpt.h	/^void SR_Build_ShowHelp(void);$/;"	p	signature:(void)
SR_GetOpt	SR_Build_GetOpt.c	/^int SR_GetOpt(SR_Option opts[], int argc, char* argv[])$/;"	f	signature:(SR_Option opts[], int argc, char* argv[])
SR_GetOpt	SR_Build_GetOpt.h	/^int SR_GetOpt(SR_Option opts[], int argc, char* argv[]);$/;"	p	signature:(SR_Option opts[], int argc, char* argv[])
SR_HashPosArray	SR_OutHashTable.h	/^typedef struct SR_HashPosArray$/;"	s
SR_HashPosArray	SR_OutHashTable.h	/^}SR_HashPosArray;$/;"	t	typeref:struct:SR_HashPosArray
SR_HashPosArray::capacity	SR_OutHashTable.h	/^    unsigned int capacity;  \/\/ maximum number of positions that can be hold in the array$/;"	m	struct:SR_HashPosArray	access:public
SR_HashPosArray::hashPos	SR_OutHashTable.h	/^    uint32_t* hashPos;      \/\/ an array to hold all positions found in the reference for a certain hash$/;"	m	struct:SR_HashPosArray	access:public
SR_HashPosArray::size	SR_OutHashTable.h	/^    unsigned int size;      \/\/ number of positions$/;"	m	struct:SR_HashPosArray	access:public
SR_HashPosArrayAlloc	SR_OutHashTable.c	/^SR_HashPosArray* SR_HashPosArrayAlloc(unsigned int capacity)$/;"	f	signature:(unsigned int capacity)
SR_HashPosArrayAlloc	SR_OutHashTable.h	/^SR_HashPosArray* SR_HashPosArrayAlloc(unsigned int capacity);$/;"	p	signature:(unsigned int capacity)
SR_HashPosArrayFree	SR_OutHashTable.c	/^void SR_HashPosArrayFree(SR_HashPosArray* hashPosArray)$/;"	f	signature:(SR_HashPosArray* hashPosArray)
SR_HashPosArrayFree	SR_OutHashTable.h	/^void SR_HashPosArrayFree(SR_HashPosArray* hashPosArray);$/;"	p	signature:(SR_HashPosArray* hashPosArray)
SR_HashPosArrayGet	SR_OutHashTable.h	33;"	d
SR_HashPosArrayInit	SR_OutHashTable.c	/^void SR_HashPosArrayInit(SR_HashPosArray* hashPosArray, unsigned int capacity)$/;"	f	signature:(SR_HashPosArray* hashPosArray, unsigned int capacity)
SR_HashPosArrayInit	SR_OutHashTable.h	/^void SR_HashPosArrayInit(SR_HashPosArray* hashPosArray, unsigned int capacity);$/;"	p	signature:(SR_HashPosArray* hashPosArray, unsigned int capacity)
SR_HashPosArrayPushBack	SR_OutHashTable.c	/^void SR_HashPosArrayPushBack(SR_HashPosArray* hashPosArray, uint32_t pos)$/;"	f	signature:(SR_HashPosArray* hashPosArray, uint32_t pos)
SR_HashPosArrayPushBack	SR_OutHashTable.h	/^void SR_HashPosArrayPushBack(SR_HashPosArray* hashPosArray, uint32_t pos);$/;"	p	signature:(SR_HashPosArray* hashPosArray, uint32_t pos)
SR_HashPosArrayReset	SR_OutHashTable.h	35;"	d
SR_Option	SR_Build_GetOpt.h	/^typedef struct SR_Option$/;"	s
SR_Option	SR_Build_GetOpt.h	/^}SR_Option;$/;"	t	typeref:struct:SR_Option
SR_Option::isFound	SR_Build_GetOpt.h	/^    Bool isFound;        \/\/ boolean variable to indicate that if we fount this option or not$/;"	m	struct:SR_Option	access:public
SR_Option::name	SR_Build_GetOpt.h	/^    char* name;          \/\/ name of this option, following a '-' character in the command line$/;"	m	struct:SR_Option	access:public
SR_Option::value	SR_Build_GetOpt.h	/^    const char* value;   \/\/ a pointer points to the value of the option in the argv array$/;"	m	struct:SR_Option	access:public
SR_OutHashTable	SR_OutHashTable.h	/^typedef struct SR_OutHashTable$/;"	s
SR_OutHashTable	SR_OutHashTable.h	/^}SR_OutHashTable;$/;"	t	typeref:struct:SR_OutHashTable
SR_OutHashTable::chr	SR_OutHashTable.h	/^    unsigned char chr;           \/\/ chromsome$/;"	m	struct:SR_OutHashTable	access:public
SR_OutHashTable::hashPosTable	SR_OutHashTable.h	/^    SR_HashPosArray* hashPosTable;  \/\/ table holds all the position of hashes found in reference$/;"	m	struct:SR_OutHashTable	access:public
SR_OutHashTable::hashSize	SR_OutHashTable.h	/^    unsigned char hashSize;      \/\/ size of hash$/;"	m	struct:SR_OutHashTable	access:public
SR_OutHashTable::md5	SR_OutHashTable.h	/^    char md5[MD5_STR_LEN + 1];   \/\/ md5 checksum string$/;"	m	struct:SR_OutHashTable	access:public
SR_OutHashTable::numHashes	SR_OutHashTable.h	/^    uint32_t  numHashes;         \/\/ total number of different hashes$/;"	m	struct:SR_OutHashTable	access:public
SR_OutHashTable::numPos	SR_OutHashTable.h	/^    uint32_t  numPos;            \/\/ total number of hash positions found in reference$/;"	m	struct:SR_OutHashTable	access:public
SR_OutHashTableAlloc	SR_OutHashTable.c	/^SR_OutHashTable* SR_OutHashTableAlloc(unsigned char hashSize)$/;"	f	signature:(unsigned char hashSize)
SR_OutHashTableAlloc	SR_OutHashTable.h	/^SR_OutHashTable* SR_OutHashTableAlloc(unsigned char hashSize);$/;"	p	signature:(unsigned char hashSize)
SR_OutHashTableFree	SR_OutHashTable.c	/^void SR_OutHashTableFree(SR_OutHashTable* pHashTable)$/;"	f	signature:(SR_OutHashTable* pHashTable)
SR_OutHashTableFree	SR_OutHashTable.h	/^void SR_OutHashTableFree(SR_OutHashTable* pHashTable);$/;"	p	signature:(SR_OutHashTable* pHashTable)
SR_OutHashTableLoad	SR_OutHashTable.c	/^void SR_OutHashTableLoad(SR_OutHashTable* pHashTable, const char* md5String, const char* refSeq, uint32_t refLen, unsigned char chr)$/;"	f	signature:(SR_OutHashTable* pHashTable, const char* md5String, const char* refSeq, uint32_t refLen, unsigned char chr)
SR_OutHashTableLoad	SR_OutHashTable.h	/^void SR_OutHashTableLoad(SR_OutHashTable* pHashTable, const char* refSeq, const char* md5String, uint32_t refLen, unsigned char chr);$/;"	p	signature:(SR_OutHashTable* pHashTable, const char* refSeq, const char* md5String, uint32_t refLen, unsigned char chr)
SR_OutHashTableReset	SR_OutHashTable.c	/^void SR_OutHashTableReset(SR_OutHashTable* pHashTable)$/;"	f	signature:(SR_OutHashTable* pHashTable)
SR_OutHashTableReset	SR_OutHashTable.h	/^void SR_OutHashTableReset(SR_OutHashTable* pHashTable);$/;"	p	signature:(SR_OutHashTable* pHashTable)
SR_OutHashTableWrite	SR_OutHashTable.c	/^off_t SR_OutHashTableWrite(FILE* hashTableOutput, const SR_OutHashTable* pHashTable)$/;"	f	signature:(FILE* hashTableOutput, const SR_OutHashTable* pHashTable)
SR_OutHashTableWrite	SR_OutHashTable.h	/^off_t SR_OutHashTableWrite(FILE* hashTableOutput, const SR_OutHashTable* pHashTable);$/;"	p	signature:(FILE* hashTableOutput, const SR_OutHashTable* pHashTable)
WriteHashSize	SR_OutHashTable.h	37;"	d
capacity	SR_OutHashTable.h	/^    unsigned int capacity;  \/\/ maximum number of positions that can be hold in the array$/;"	m	struct:SR_HashPosArray	access:public
chr	SR_OutHashTable.h	/^    unsigned char chr;           \/\/ chromsome$/;"	m	struct:SR_OutHashTable	access:public
faInput	SR_Build_GetOpt.h	/^    FILE* faInput;            \/\/ input stream of the fasta file$/;"	m	struct:SR_Build_Pars	access:public
hashPos	SR_OutHashTable.h	/^    uint32_t* hashPos;      \/\/ an array to hold all positions found in the reference for a certain hash$/;"	m	struct:SR_HashPosArray	access:public
hashPosTable	SR_OutHashTable.h	/^    SR_HashPosArray* hashPosTable;  \/\/ table holds all the position of hashes found in reference$/;"	m	struct:SR_OutHashTable	access:public
hashSize	SR_Build_GetOpt.h	/^    unsigned char hashSize;   \/\/ hash size used to index the reference$/;"	m	struct:SR_Build_Pars	access:public
hashSize	SR_OutHashTable.h	/^    unsigned char hashSize;      \/\/ size of hash$/;"	m	struct:SR_OutHashTable	access:public
hashTableOutput	SR_Build_GetOpt.h	/^    FILE* hashTableOutput;    \/\/ output stream of the hash table file$/;"	m	struct:SR_Build_Pars	access:public
isFound	SR_Build_GetOpt.h	/^    Bool isFound;        \/\/ boolean variable to indicate that if we fount this option or not$/;"	m	struct:SR_Option	access:public
main	SR_Build_Main.c	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
md5	SR_OutHashTable.h	/^    char md5[MD5_STR_LEN + 1];   \/\/ md5 checksum string$/;"	m	struct:SR_OutHashTable	access:public
name	SR_Build_GetOpt.h	/^    char* name;          \/\/ name of this option, following a '-' character in the command line$/;"	m	struct:SR_Option	access:public
numHashes	SR_OutHashTable.h	/^    uint32_t  numHashes;         \/\/ total number of different hashes$/;"	m	struct:SR_OutHashTable	access:public
numPos	SR_OutHashTable.h	/^    uint32_t  numPos;            \/\/ total number of hash positions found in reference$/;"	m	struct:SR_OutHashTable	access:public
offsetOutput	SR_Build_GetOpt.h	/^    FILE* offsetOutput;       \/\/ output stream of offset position file of the reference and hash table files$/;"	m	struct:SR_Build_Pars	access:public
refOutput	SR_Build_GetOpt.h	/^    FILE* refOutput;          \/\/ output stream of the reference file$/;"	m	struct:SR_Build_Pars	access:public
size	SR_OutHashTable.h	/^    unsigned int size;      \/\/ number of positions$/;"	m	struct:SR_HashPosArray	access:public
value	SR_Build_GetOpt.h	/^    const char* value;   \/\/ a pointer points to the value of the option in the argv array$/;"	m	struct:SR_Option	access:public
